# 

## 模块化概述
> javascript不是一种模块化编程语言，刚开始不支持类'class'，更遑论"模块"（module）了，随着前端发展对模块化需求越来越大（命名冲突、文件依赖），模块经厉了从简单的模块写法到AMD和CMD规范的出现，再到ES6发布，目前已经很方便的可以在JavaScript中使用 类和 模块 了
###模块化规范
* 浏览器规范
    - AMD(require.js)
    - CMD（Sea.js）
    - ES6
* 服务端规范
    - commonJS（事件循环.md）
    - Node的应用是由模块组成的
### commonJS的特点
* 所有代码运行在当前模块作用域，不会污染全局作用域
* 模块同步加载，根据代码执行顺序载入
* 模块可以多次加载，只会在第一次加载的时候运行一次，运行结果被缓存
* 以后再次加载模块，会直接从缓存中读取结果
## module 对象详解
### module对象的属性
* id： 当前模块的id
* exports： 表示当前模块暴露给外部的值
* parent： 是一个对象，表示调用当前模块的模块
* children： 是一个对象，表示当前模块调用的模块
* filename： 模块的绝对路径
* paths： 从当前模块开始查找node_modules目录，然后依次进入父目录，查找父目录的node_modules目录，直到找到根目录下的node_modules目录
* loaded： 一个布尔值，表示当前模块是否全部被加载
### 模块分类
* 核心模块
> node.js 提供的模块，例如http模块、fs模块，称之为核心模块。核心模块在node的源代码编译过程中就编译成了二进制文件，在node进程启动的时候，部分核心模块直接加载进内存中，因此这部分模块不需要手动加载，而且在路径分析中优先判断，加载速度是最快的
* 文件模块
> 用户自己写的模块，称为文件模块，文件模块是按需加载的，速度比较慢
### module.exports与exports
> module。exports就是为了解决exports直接赋值的问题而产生的
* module.exports
> exports对象和module.exports都是应用类型变量，指向同一个内存地址，在node中，两者一开始都指向一个空对象
* exports
> exports通过形参的方式传入，直接赋值给形参使用，但是并不能改变作用域以外的值
不允许直接对exports赋值： exports = {};
## require方法详解
### 模块引入规则
> 模块引入规则：通过exports或者module.exports抛出一个模块，通过require方法传入模块标识符，然后node 根据一定的规则引入该模块，我们就可以在模块中定义方法和属性
### 加载步骤
* 路径分析
    - 核心模块
    - 以`.`或者`../`开始的显贵路径文件模块
    - 以 `/`开始的绝对路径模块
    - 非路径形式的模块
* 文件定位
    - 扩展名的分析 .js/.node(编译后的文件)/.json
    - 目标文件和包分析
* 编译执行

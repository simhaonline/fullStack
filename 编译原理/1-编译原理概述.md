# 编译器

## 什么是编译器？
> 计算机设备包括个人计算机、大型机、嵌入式系统、智能设备等核心问题都是软件的构造
目前绝大多数的软件都是由高级语言书写的（成百上千种高级语言）
这些语言是如何运行在计算机系统上的呢？----------> **编译器**

**编译器**是一个**程序**: 核心功能是把`源代码`翻译成`目标代码`

* 源代码： C/C++、Java、C#、html、SQL...
* 目标代码：x86、IA64、ARM、MIPS...

## 编译器的核心功能
![功能](./img/编译器核心功能.png )

## 编译器和解释器
* 解释器也是处理程序的一种**程序** 
![功能](./img/编译器和解释器.jpg)
* 解释器是一种在线的方式（处理代码的过程中，同时将结果展示出来），但编译器是一种离线的方式（静态分析源代码，生成结果代码后等待执行）
* 两者有很多的共同点

## 为什么学习编译原理
* 编译原理集中体现了计算机科学的很多核心思想
    - 算法
    - 数据结构
    - 软件工程
* 编译器是其他领域重要研究基础
* 编译器本身就是一个非常重要的研究领域
    - 新的语言
    - 大型软件的构造和维护

## 编译器的结构
编译器 具有非常**模块化**的高层结构，可以看成多个阶段构成的"流水线"结构
* 未优化的结构
![编译器结构](./img/编译器结构-2.png)

* 更复杂的结构
![编译器结构](./img/编译器结构-1.png)

编译器由多个阶段组成，每个阶段都要处理不同的问题，使用不同的理论、数据结构和算法
因此，编译器设计中的重要问题是如何合理的划分组织各个阶段
    - 接口清晰
    - 编译器容易实现、维护

## 简单编译器的例子
* 源语言： 加法表达式 Sum，有以下两种语法形式
    - 整型数字： n
    - 加法： e1 + e2
* 目标机器： 栈式计算机 Stack
    - 一个操作数栈
    - 两条指令
        + 压栈指令：push n
        + 加法指令： add

* 任务：编译程序`1 + 2 + 3`到栈式计算机。编译器阶段如下：
    - 阶段一：词法语法分析
        + 词法分析 将`1+2+3`分为`1`、`+`、`2`、`+`、`3`五个部分
        + 语法分析 将上面五个部分分别进行分析：每个部分是否满足`Sum`语法的要求
    - 阶段二：语法树的构建
    ![语法树](./img/语法树.png)
    - 阶段三：代码生成
        + 后续遍历post-order（[二叉树的遍历算法之一](https://www.jianshu.com/p/17548f7e5b1a)）
        ![代码](./img/生成代码.png)
        
            1. 读入1 => 栈 push `1`
            2. 读入2 => 栈 push `2`
            3. 读入+ => add、栈 pop `2`、栈 pop `1`、 栈 push `1 + 2` 的结果 `3`
            4. 读入3 => 栈 push `3`
            5. 读入+ => add、栈 pop `3`、栈 pop `3`、 栈 push `3 + 3` 的结果 `6`
            
## 编译器的重要的一些性质
作为一个软件系统，编译器也有很多方面的性质：
    - 编译的效率，即编译一个程序的速度和代价；
    - 编译生成代码的效率，即编译器生成的可执行程序的运行效率；
    - 编译生成代码的质量，即和源代码语义等价性；

### 分析树
 ![分析树11](./img/分析树11.png)
* 分析树编码了句子的推导过程 但是包含很多不必要的信息，如上面的`（` `）`等，占用了额外的存储空间
* 对于**表达式**而言，编译只需要知道运算符和运算数（优先级、结合性等已经在语法分析部分处理掉了）
* 对于**语句、函数**等语言其他构造而言也一样（例如，编译器不关心赋值符号是`=`还是`:=`或其它）

### 上面分析树对应的语法树
 ![语法树](./img/语法树11.png)

### 具体语法和抽象语法
* **具体语法**是语法分析器使用的语法

```
E  -> E + T
    | T
T  -> T * F
    | F
F   -> n
    | (E)
```

* **抽象语法**是用来表达语法结构的内部表示
```
E   -> n
    | E + E
    | E * E
```

> 现代编译器一般都采用抽象语法作为前端(词法语法分析）和后端（代码生成）的接口

### 抽象语法树数据结构
在编译器中，为了定义抽象语法树，需要使用**实现语言**来定义一组数据结构(和实现语言密切相关)。早期的编译器有的不采用抽象语法树数据结构，直接在语法制导翻译中生成代码，但现代的编译器一般采用抽象语法树作为语法分析
器的输出（更好的系统的支持，简化编译器的设计 ）

### 抽象语法树的定义（C语言版）
```
E    -> n
    | E + E
    | E * E
```

```
enum kind {E_INT, E_ADD, E_TIMES};
struct Exp {
    enum kind kind;
};
struct Exp_Int{
    enum kind kind;
    int n;
};
struct Exp_Add{
    enum kind kind;
    struct Exp *left;
    struct Exp *right;
};
struct Exp_Times{
    enum kind kind;
    struct Exp *left;
    struct Exp *right;
};

struct Exp_Int *Exp_Int_new (int n)
{
    struct Exp_Int *p = malloc (sizeof(*p));
    p->kind = E_INT;
    p->n = n;
    return p;
}
struct Exp_Add *Exp_Add_new(struct Exp *left, struct Exp *right)
{
    struct Exp_Add *p = malloc (sizeof(*p));
    p->kind = E_ADD;
    p->left = left;
     p->right = right;
    return p;
}

```

```
/* 用数据结构来编码程序“2+3*4” */
e1 = Exp_Int_new (2);
e2 = Exp_Int_new (3);
e3 = Exp_Int_new (4);
e4 = Exp_Times_new (e2, e3);
e5 = Exp_Add_new (e1, e4);
```
